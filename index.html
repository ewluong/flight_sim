<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta charset="UTF-8">
    <title>Flight Simulator 2025</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            background: #000000; /* Dark background for cyberpunk feel */
        }
        canvas { 
            display: block;
            touch-action: none;
        }
        #metrics {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Courier New', monospace;
            color: #00ff00; /* Neon green */
            text-shadow: 0 0 5px #00ff00;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border: 2px solid #00ff00;
            box-shadow: 0 0 10px #00ff00;
            border-radius: 5px;
            transition: opacity 0.3s ease;
            cursor: pointer;
        }
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #000000, #1a1a3a); /* Cyberpunk gradient */
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
            z-index: 1000;
        }
        #startButton {
            padding: 20px 40px;
            font-size: 24px;
            cursor: pointer;
            background: #00ff00;
            color: #000000;
            border: 2px solid #00ff00;
            box-shadow: 0 0 10px #00ff00;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }
        #leftJoystick, #rightJoystick {
            position: fixed;
            bottom: 50px;
            width: 120px;
            height: 120px;
            z-index: 1000;
            opacity: 0.7;
            display: none;
        }
        #leftJoystick { left: 50px; }
        #rightJoystick { right: 50px; }
        #scoreOverlay {
            position: fixed;
            top: 20px;
            right: 20px;
            font-family: 'Courier New', monospace;
            color: #ff00ff; /* Neon pink */
            text-shadow: 0 0 5px #ff00ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
            border-radius: 5px;
            z-index: 1000;
            transition: transform 0.2s;
        }
        #connectionUI {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ffff; /* Neon cyan */
            text-shadow: 0 0 5px #00ffff;
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px #00ffff;
            border-radius: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
            transition: opacity 0.3s ease;
        }
        @media (max-width: 768px) {
            #leftJoystick, #rightJoystick { display: block; }
            #metrics { font-size: 12px; max-width: 150px; }
        }
    </style>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
</head>
<body>
    <div id="metrics"></div>
    <div id="startScreen">
        <h1 style="font-size: 36px; margin-bottom: 20px; padding: 14px; text-align: center; text-transform: uppercase;">
            CYBERPUNK<br>FLIGHT SIMULATOR
        </h1>
        <button id="startButton">Start</button>
        <p style="margin-top: 20px; font-size: 18px;">Press any key to start</p>
    </div>
    <div id="leftJoystick"></div>
    <div id="rightJoystick"></div>
    <div id="scoreOverlay">ðŸŽˆ0/100</div>
    <div id="connectionUI"></div>
    <script>
        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a3a); // Dark blue-purple sky
        const fogColor = new THREE.Color(0x1a1a3a);
        scene.fog = new THREE.Fog(fogColor, 100, 500);

        const camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Player Aircraft
        const playerGroup = new THREE.Group();
        const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 }); // Dark gray
        const wingMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
        const trimMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5 }); // Neon green
        const bodyGeometry = new THREE.BoxGeometry(0.8, 0.8, 4);
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        playerGroup.add(body);
        const noseGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.8);
        const nose = new THREE.Mesh(noseGeometry, bodyMaterial);
        nose.position.set(0, -0.1, -2.2);
        playerGroup.add(nose);
        const wingGeometry = new THREE.BoxGeometry(7, 0.1, 1.2);
        const wings = new THREE.Mesh(wingGeometry, wingMaterial);
        wings.position.y = 0.3;
        playerGroup.add(wings);
        const tailWingGeometry = new THREE.BoxGeometry(2.2, 0.1, 0.8);
        const tailWing = new THREE.Mesh(tailWingGeometry, wingMaterial);
        tailWing.position.set(0, 0.2, 1.8);
        playerGroup.add(tailWing);
        const stabilizerGeometry = new THREE.BoxGeometry(0.1, 0.8, 1.2);
        const stabilizer = new THREE.Mesh(stabilizerGeometry, wingMaterial);
        stabilizer.position.set(0, 0.5, 1.8);
        playerGroup.add(stabilizer);
        const windowGeometry = new THREE.BoxGeometry(0.82, 0.82, 1.2);
        const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, emissive: 0x00ffff, emissiveIntensity: 0.3 }); // Neon cyan
        const windows = new THREE.Mesh(windowGeometry, windowMaterial);
        windows.position.set(0, 0.1, -0.8);
        playerGroup.add(windows);
        const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8);
        const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const leftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        leftWheel.rotation.z = Math.PI / 2;
        leftWheel.position.set(-1, -0.6, 0);
        playerGroup.add(leftWheel);
        const rightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        rightWheel.rotation.z = Math.PI / 2;
        rightWheel.position.set(1, -0.6, 0);
        playerGroup.add(rightWheel);
        const noseWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        noseWheel.rotation.z = Math.PI / 2;
        noseWheel.position.set(0, -0.6, -1.5);
        playerGroup.add(noseWheel);
        scene.add(playerGroup);
        const player = playerGroup;
        player.position.set(0, 36, 90);

        // Ground and Runway
        const groundGeometry = new THREE.BoxGeometry(1000, 35, 2000);
        const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 0, flatShading: true });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.position.set(150, 17.5, 0);
        ground.receiveShadow = true;
        scene.add(ground);
        const runwayGeometry = new THREE.BoxGeometry(10, 0.001, 200);
        const runwayMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
        runway.position.set(0, 35.01, 0);
        runway.receiveShadow = true;
        scene.add(runway);
        const stripeGeometry = new THREE.BoxGeometry(1, 0.001, 5);
        const stripeMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff }); // Neon cyan
        for (let i = -90; i <= 90; i += 10) {
            const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            stripe.position.set(0, 35.02, i);
            stripe.receiveShadow = true;
            scene.add(stripe);
        }

        // ATC Tower
        const towerGroup = new THREE.Group();
        const towerBaseGeometry = new THREE.BoxGeometry(4, 12.5, 4);
        const towerBaseMaterial = new THREE.MeshPhongMaterial({ color: 0x222222, roughness: 0.8 });
        const towerBase = new THREE.Mesh(towerBaseGeometry, towerBaseMaterial);
        towerBase.position.y = 6.25;
        towerBase.castShadow = true;
        towerBase.receiveShadow = true;
        towerGroup.add(towerBase);
        const controlRoomGeometry = new THREE.BoxGeometry(6, 3, 6);
        const controlRoomMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6, shininess: 90, emissive: 0x00ffff, emissiveIntensity: 0.5 });
        const controlRoom = new THREE.Mesh(controlRoomGeometry, controlRoomMaterial);
        controlRoom.position.y = 14;
        controlRoom.castShadow = true;
        towerGroup.add(controlRoom);
        const roofGeometry = new THREE.ConeGeometry(4.25, 2, 4);
        const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.position.y = 16.5;
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = true;
        towerGroup.add(roof);
        const antennaGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
        const antennaMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
        antenna.position.y = 19;
        antenna.castShadow = true;
        towerGroup.add(antenna);
        towerGroup.position.set(15, 35, 0);
        scene.add(towerGroup);
        const towerBaseDetailGeometry = new THREE.BoxGeometry(8, 0.25, 8);
        const towerBaseDetailMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const towerBaseDetail = new THREE.Mesh(towerBaseDetailGeometry, towerBaseDetailMaterial);
        towerBaseDetail.position.set(15, 35.1, 0);
        towerBaseDetail.receiveShadow = true;
        scene.add(towerBaseDetail);

        // Windsock
        const windsockGroup = new THREE.Group();
        const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 6, 8);
        const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 }); // Neon green
        const pole = new THREE.Mesh(poleGeometry, poleMaterial);
        pole.position.y = 3;
        pole.castShadow = true;
        windsockGroup.add(pole);
        const segments = 6;
        const sockSegments = [];
        const segmentGeometry = new THREE.CylinderGeometry(0.4, 0.3, 0.6, 8);
        const sockMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, side: THREE.DoubleSide, flatShading: true });
        for (let i = 0; i < segments; i++) {
            const segment = new THREE.Mesh(segmentGeometry, sockMaterial);
            segment.position.set(0, 5.5, i * 0.3);
            segment.rotation.x = Math.PI / 2;
            segment.rotation.y = Math.PI / 4;
            segment.castShadow = true;
            sockSegments.push(segment);
            windsockGroup.add(segment);
        }
        windsockGroup.position.set(8, 35, -30);
        windsockGroup.rotation.y = Math.PI / 4;
        scene.add(windsockGroup);
        let windSpeed = 0.2;
        let windDirection = 0;
        let windChangeTimer = 0;
        const WIND_CHANGE_INTERVAL = 500;

        function animateWindsock() {
            windChangeTimer += deltaTime * 60;
            if (windChangeTimer > WIND_CHANGE_INTERVAL) {
                windSpeed = Math.max(0.1, Math.min(0.8, windSpeed + (Math.random() - 0.5) * 0.1));
                windDirection += (Math.random() - 0.5) * 0.1;
                windChangeTimer = 0;
            }
            const time = Date.now() * 0.001;
            const playerWindEffect = currentSpeed * 2;
            const playerDirection = -yawAngle;
            const totalWindSpeed = Math.sqrt(
                Math.pow(windSpeed * Math.cos(windDirection) + playerWindEffect * Math.cos(playerDirection), 2) +
                Math.pow(windSpeed * Math.sin(windDirection) + playerWindEffect * Math.sin(playerDirection), 2)
            );
            const totalWindDirection = Math.atan2(
                windSpeed * Math.sin(windDirection) + playerWindEffect * Math.sin(playerDirection),
                windSpeed * Math.cos(windDirection) + playerWindEffect * Math.cos(playerDirection)
            );
            sockSegments.forEach((segment, index) => {
                const offset = index * 0.1;
                const windEffect = totalWindSpeed * (1 + index * 0.1);
                segment.position.y = 5.5 + Math.sin(time * 2 + offset) * 0.1;
                segment.position.x = Math.sin(totalWindDirection) * windEffect;
                segment.position.z = index * 0.3 + Math.cos(totalWindDirection) * windEffect;
                segment.rotation.x = Math.PI / 2 + Math.sin(time * 3 + offset) * 0.1;
                segment.rotation.y = totalWindDirection;
                segment.rotation.z = Math.sin(time * 4 + offset * 2) * 0.1 * totalWindSpeed;
            });
        }

        // Ocean and Beach
        const oceanGeometry = new THREE.PlaneGeometry(2000, 2000);
        const oceanMaterial = new THREE.MeshPhongMaterial({ color: 0x001122, shininess: 60 });
        const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
        ocean.rotation.x = -Math.PI / 2;
        ocean.position.set(-1450, 35, 0);
        ocean.receiveShadow = true;
        scene.add(ocean);
        const beachGeometry = new THREE.PlaneGeometry(100, 2000);
        const beachMaterial = new THREE.MeshPhongMaterial({ color: 0x886644 });
        const beach = new THREE.Mesh(beachGeometry, beachMaterial);
        beach.rotation.x = -Math.PI / 2;
        beach.position.set(-400, 35, 0);
        beach.receiveShadow = true;
        scene.add(beach);

        // Buildings
        const buildings = [];
        function createBuilding() {
            const height = Math.random() * 5 + 3;
            const width = Math.random() * 4 + 3;
            const depth = Math.random() * 4 + 3;
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const wallCanvas = document.createElement('canvas');
            wallCanvas.width = 128;
            wallCanvas.height = 128;
            const wallCtx = wallCanvas.getContext('2d');
            wallCtx.fillStyle = '#111111'; // Dark gray
            wallCtx.fillRect(0, 0, 128, 128);
            const windowGeometry = new THREE.BoxGeometry(width * 0.2, height * 0.2, 0.1);
            const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5 });
            const wallTexture = new THREE.CanvasTexture(wallCanvas);
            const materials = [
                new THREE.MeshPhongMaterial({ map: wallTexture }),
                new THREE.MeshPhongMaterial({ map: wallTexture }),
                new THREE.MeshPhongMaterial({ color: 0xff00ff }), // Neon pink roof
                new THREE.MeshPhongMaterial({ map: wallTexture }),
                new THREE.MeshPhongMaterial({ map: wallTexture }),
                new THREE.MeshPhongMaterial({ map: wallTexture })
            ];
            const building = new THREE.Mesh(buildingGeometry, materials);
            building.castShadow = true;
            building.receiveShadow = true;
            building.position.set(Math.random() * 400 - 200, height / 2 + 35, Math.random() * 800 - 400);
            while (Math.abs(building.position.x) < 30 && Math.abs(building.position.z) < 150) {
                building.position.x = Math.random() * 400 - 200;
                building.position.z = Math.random() * 800 - 400;
            }
            const windowPositions = [
                [-width / 4, height * 0.05, depth / 2],
                [width / 4, height * 0.05, depth / 2],
                [-width / 4, height * 0.25, depth / 2],
                [width / 4, height * 0.25, depth / 2]
            ];
            windowPositions.forEach(pos => {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(...pos);
                building.add(window);
            });
            const light = new THREE.PointLight(0xff00ff, 1, 20); // Neon pink light
            light.position.set(0, height + 2, 0);
            building.add(light);
            building.boundingBox = new THREE.Box3().setFromObject(building);
            buildings.push(building);
            scene.add(building);
        }
        for (let i = 0; i < 100; i++) createBuilding();

        // Houses
        const houses = [];
        function createHouse() {
            const houseGroup = new THREE.Group();
            const width = 4 + Math.random() * 4;
            const height = 6 + Math.random() * 8;
            const depth = 4 + Math.random() * 4;
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const buildingMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = height / 2;
            houseGroup.add(building);
            const roofHeight = height * 0.3;
            const roofGeometry = new THREE.ConeGeometry(width * 0.8, roofHeight, 4);
            const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = height + roofHeight / 2;
            roof.rotation.y = Math.PI / 4;
            houseGroup.add(roof);
            const windowSize = width * 0.2;
            const windowGeometry = new THREE.BoxGeometry(windowSize, windowSize, 0.1);
            const windowMaterial = new THREE.MeshPhongMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 0.5 });
            const windowPositions = [
                [-width / 4, height / 2, depth / 2],
                [width / 4, height / 2, depth / 2],
                [-width / 4, height * 0.75, depth / 2],
                [width / 4, height * 0.75, depth / 2]
            ];
            windowPositions.forEach(pos => {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(...pos);
                houseGroup.add(window);
            });
            const doorWidth = width * 0.3;
            const doorHeight = height * 0.4;
            const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, 0.1);
            const doorMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, doorHeight / 2, depth / 2);
            houseGroup.add(door);
            houseGroup.traverse(object => {
                if (object instanceof THREE.Mesh) {
                    object.castShadow = true;
                    object.receiveShadow = true;
                }
            });
            let x = -400 + Math.random() * 600;
            let z = Math.random() * 1600 - 800;
            while (Math.abs(x) < 30 && Math.abs(z) < 150) {
                x = -400 + Math.random() * 600;
                z = Math.random() * 1600 - 800;
            }
            houseGroup.position.set(x, 35, z);
            houseGroup.rotation.y = Math.random() * Math.PI * 2;
            houses.push(houseGroup);
            scene.add(houseGroup);
        }
        for (let i = 0; i < 80; i++) createHouse();

        // Castle
        function createCastle() {
            const castleGroup = new THREE.Group();
            castleGroup.parts = [];
            const keepGeometry = new THREE.BoxGeometry(40, 60, 40);
            const stoneMaterial = new THREE.MeshPhongMaterial({ color: 0x808080, flatShading: true });
            const keep = new THREE.Mesh(keepGeometry, stoneMaterial);
            keep.position.y = 30;
            keep.castlePartType = 'keep';
            keep.health = 10;
            castleGroup.parts.push(keep);
            castleGroup.add(keep);
            const towerGeometry = new THREE.CylinderGeometry(6, 8, 70, 8);
            const towerPositions = [
                [-22, 35, -22], [22, 35, -22], [-22, 35, 22], [22, 35, 22]
            ];
            towerPositions.forEach(pos => {
                const tower = new THREE.Mesh(towerGeometry, stoneMaterial);
                tower.position.set(...pos);
                tower.castlePartType = 'tower';
                tower.health = 5;
                castleGroup.parts.push(tower);
                castleGroup.add(tower);
                const roofGeometry = new THREE.ConeGeometry(8, 15, 8);
                const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(pos[0], pos[1] + 42, pos[2]);
                roof.castlePartType = 'roof';
                roof.health = 2;
                castleGroup.parts.push(roof);
                castleGroup.add(roof);
            });
            for (let x = -18; x <= 18; x += 4) {
                for (let z = -18; z <= 18; z += 4) {
                    if (x === -18 || x === 18 || z === -18 || z === 18) {
                        const merlon = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 3), stoneMaterial);
                        merlon.position.set(x, 62, z);
                        merlon.castlePartType = 'merlon';
                        merlon.health = 1;
                        castleGroup.parts.push(merlon);
                        castleGroup.add(merlon);
                    }
                }
            }
            castleGroup.position.set(100, 35.2, -300);
            return castleGroup;
        }
        const castle = createCastle();
        scene.add(castle);

        // Lighting
        const sunLight = new THREE.DirectionalLight(0x00ffff, 0.5); // Cyan light
        sunLight.position.set(100, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(4096, 4096);
        sunLight.shadow.camera.near = 0.1;
        sunLight.shadow.camera.far = 1000;
        sunLight.shadow.camera.left = -500;
        sunLight.shadow.camera.right = 500;
        sunLight.shadow.camera.top = 500;
        sunLight.shadow.camera.bottom = -500;
        sunLight.shadow.bias = -0.001;
        scene.add(sunLight);
        const ambientLight = new THREE.AmbientLight(0x222222, 0.3);
        scene.add(ambientLight);

        // Runway Lights
        const runwayLights = [];
        const approachLights = [];
        function createRunwayLights() {
            const edgeLightGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.2);
            const edgeLightMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x00ffff, emissiveIntensity: 0 });
            for (let z = -95; z <= 95; z += 10) {
                const leftLight = new THREE.Mesh(edgeLightGeometry, edgeLightMaterial.clone());
                leftLight.position.set(-5, 35.2, z);
                scene.add(leftLight);
                const rightLight = new THREE.Mesh(edgeLightGeometry, edgeLightMaterial.clone());
                rightLight.position.set(5, 35.2, z);
                scene.add(rightLight);
                const leftPointLight = new THREE.PointLight(0x00ffff, 0, 10);
                leftPointLight.position.copy(leftLight.position);
                scene.add(leftPointLight);
                const rightPointLight = new THREE.PointLight(0x00ffff, 0, 10);
                rightPointLight.position.copy(rightLight.position);
                scene.add(rightPointLight);
                runwayLights.push({ mesh: leftLight, light: leftPointLight }, { mesh: rightLight, light: rightPointLight });
            }
            for (let z = 150; z >= 100; z -= 10) {
                const approachLight = new THREE.Mesh(edgeLightGeometry, edgeLightMaterial.clone());
                approachLight.position.set(0, 35.2, z);
                scene.add(approachLight);
                const pointLight = new THREE.PointLight(0x00ffff, 0, 10);
                pointLight.position.copy(approachLight.position);
                scene.add(pointLight);
                approachLights.push({ mesh: approachLight, light: pointLight, baseIntensity: 0 });
            }
        }
        createRunwayLights();
        let lastApproachLightUpdate = 0;
        const APPROACH_LIGHT_INTERVAL = 100;
        let currentApproachLightIndex = 0;
        function updateApproachLights() {
            const currentTime = Date.now();
            const isNight = gameTime < 6000 || gameTime > 18000;
            const isDusk = gameTime >= 17000 && gameTime <= 19000;
            const isDawn = gameTime >= 5000 && gameTime <= 7000;
            if (isNight || isDusk || isDawn) {
                if (currentTime - lastApproachLightUpdate > APPROACH_LIGHT_INTERVAL) {
                    approachLights.forEach(light => {
                        light.mesh.material.emissiveIntensity = light.baseIntensity;
                        light.light.intensity = light.baseIntensity * 2;
                    });
                    if (approachLights[currentApproachLightIndex]) {
                        approachLights[currentApproachLightIndex].mesh.material.emissiveIntensity = 1;
                        approachLights[currentApproachLightIndex].light.intensity = 2;
                    }
                    currentApproachLightIndex = (currentApproachLightIndex + 1) % approachLights.length;
                    lastApproachLightUpdate = currentTime;
                }
            } else {
                approachLights.forEach(light => {
                    light.mesh.material.emissiveIntensity = 0;
                    light.light.intensity = 0;
                });
            }
        }

        // Clouds
        const clouds = [];
        function createLowCloud() {
            const cloudGroup = new THREE.Group();
            const blockGeometry = new THREE.BoxGeometry(4, 2, 4);
            const cloudMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.9, flatShading: true, emissive: 0x00ffff, emissiveIntensity: 0.1 });
            const width = 4 + Math.floor(Math.random() * 3);
            const length = 5 + Math.floor(Math.random() * 4);
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < length; z++) {
                    const height = Math.random() > 0.5 ? 2 : 3;
                    for (let y = 0; y < height; y++) {
                        const block = new THREE.Mesh(blockGeometry, cloudMaterial);
                        block.position.set(x * 3.5 + (Math.random() - 0.5) * 0.5, y * 1.5, z * 3.5 + (Math.random() - 0.5) * 0.5);
                        cloudGroup.add(block);
                    }
                }
            }
            cloudGroup.position.y = 60 + Math.random() * 60;
            return cloudGroup;
        }
        function createMidCloud() {
            const cloudGroup = new THREE.Group();
            const blockGeometry = new THREE.BoxGeometry(4, 1.5, 4);
            const cloudMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8, flatShading: true, emissive: 0x00ffff, emissiveIntensity: 0.1 });
            const width = 5 + Math.floor(Math.random() * 4);
            const length = 6 + Math.floor(Math.random() * 5);
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < length; z++) {
                    if (Math.random() > 0.3) {
                        const block = new THREE.Mesh(blockGeometry, cloudMaterial);
                        block.position.set(x * 4 + (Math.random() - 0.5), 0, z * 4 + (Math.random() - 0.5));
                        cloudGroup.add(block);
                    }
                }
            }
            cloudGroup.position.y = 195 + Math.random() * 255;
            return cloudGroup;
        }
        function createHighCloud() {
            const cloudGroup = new THREE.Group();
            const blockGeometry = new THREE.BoxGeometry(5, 0.5, 5);
            const cloudMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.6, flatShading: true, emissive: 0x00ffff, emissiveIntensity: 0.1 });
            const width = 8 + Math.floor(Math.random() * 5);
            const length = 10 + Math.floor(Math.random() * 6);
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < length; z++) {
                    if (Math.random() > 0.5) {
                        const block = new THREE.Mesh(blockGeometry, cloudMaterial);
                        block.position.set(x * 5 + (Math.random() - 0.5) * 2, 0, z * 5 + (Math.random() - 0.5) * 2);
                        cloudGroup.add(block);
                    }
                }
            }
            cloudGroup.position.y = 450 + Math.random() * 150;
            return cloudGroup;
        }
        for (let i = 0; i < 50; i++) {
            const cloud = createLowCloud();
            cloud.position.set(Math.random() * 1400 - 700, cloud.position.y, Math.random() * 1400 - 700);
            clouds.push(cloud);
            scene.add(cloud);
        }
        for (let i = 0; i < 40; i++) {
            const cloud = createMidCloud();
            cloud.position.set(Math.random() * 1600 - 800, cloud.position.y, Math.random() * 1600 - 800);
            clouds.push(cloud);
            scene.add(cloud);
        }
        for (let i = 0; i < 30; i++) {
            const cloud = createHighCloud();
            cloud.position.set(Math.random() * 1800 - 900, cloud.position.y, Math.random() * 1800 - 900);
            clouds.push(cloud);
            scene.add(cloud);
        }
        function updateClouds() {
            clouds.forEach(cloud => {
                const speed = (cloud.position.y > 400 ? 0.2 : cloud.position.y > 200 ? 0.15 : 0.1) * deltaTime * 60;
                cloud.position.x += speed;
                if (cloud.position.x > 700) {
                    cloud.position.x = -700;
                    cloud.position.z = Math.random() * 1400 - 700;
                }
            });
        }

        // Moon
        const moonTextureLoader = new THREE.TextureLoader();
        const moonGeometry = new THREE.SphereGeometry(100, 32, 32);
        const moonMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0, fog: false });
        moonMaterial.color.multiplyScalar(1.5);
        moonTextureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/moon_1024.jpg', texture => {
            texture.repeat.x = -1;
            texture.offset.x = 1;
            moonMaterial.map = texture;
            moonMaterial.needsUpdate = true;
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(400, 500, -500);
        moon.rotation.y = Math.PI;
        scene.add(moon);

        // Ships
        const ships = [];
        function createShip() {
            const shipGroup = new THREE.Group();
            const length = 10 + Math.random() * 20;
            const width = length * 0.2;
            const height = length * 0.15;
            const hullGeometry = new THREE.BoxGeometry(width, height, length);
            const hullMaterial = new THREE.MeshPhongMaterial({ color: Math.random() > 0.5 ? 0x334455 : 0x445566 });
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.position.y = height / 2;
            shipGroup.add(hull);
            const deckCount = Math.floor(Math.random() * 3) + 1;
            for (let i = 0; i < deckCount; i++) {
                const deckWidth = width * 0.8;
                const deckLength = length * (0.2 + Math.random() * 0.2);
                const deckHeight = height * 0.8;
                const deckGeometry = new THREE.BoxGeometry(deckWidth, deckHeight, deckLength);
                const deckMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.3 });
                const deck = new THREE.Mesh(deckGeometry, deckMaterial);
                deck.position.set(0, height + deckHeight / 2, (length / 3) * (i - 1));
                shipGroup.add(deck);
            }
            const stackRadius = width * 0.15;
            const stackHeight = height * 2;
            const stackGeometry = new THREE.CylinderGeometry(stackRadius, stackRadius, stackHeight);
            const stackMaterial = new THREE.MeshPhongMaterial({ color: Math.random() > 0.5 ? 0xdd3311 : 0x333333 });
            const stack = new THREE.Mesh(stackGeometry, stackMaterial);
            stack.position.set(0, height + stackHeight / 2, -length / 4);
            shipGroup.add(stack);
            shipGroup.position.set(Math.random() * 500 - 1200, 35.5, Math.random() * 1400 - 700);
            shipGroup.rotation.y = Math.random() * Math.PI * 2;
            shipGroup.traverse(object => {
                if (object instanceof THREE.Mesh) {
                    object.castShadow = true;
                    object.receiveShadow = true;
                }
            });
            scene.add(shipGroup);
            return shipGroup;
        }
        for (let i = 0; i < 20; i++) ships.push(createShip());
        function updateShips() {
            ships.forEach(ship => {
                const time = performance.now() * 0.001;
                ship.position.y = 35.5 + Math.sin(time) * 0.1;
                ship.rotation.x = Math.sin(time) * 0.02;
            });
        }

        // Balloons
        const targets = [];
        function createBalloonTarget() {
            const balloonGroup = new THREE.Group();
            const balloonColors = [0xff0000, 0xffff00, 0x00ff00, 0xff69b4, 0x0000ff, 0x800080, 0xffffff, 0x000000];
            const sizeScale = 0.8 + Math.random() * 2.2;
            const balloonGeometry = new THREE.SphereGeometry(2, 16, 16);
            const balloonMaterial = new THREE.MeshPhongMaterial({
                color: balloonColors[Math.floor(Math.random() * balloonColors.length)],
                shininess: 50,
                transparent: true,
                opacity: 0.85
            });
            const balloon = new THREE.Mesh(balloonGeometry, balloonMaterial);
            balloon.scale.set(sizeScale, sizeScale, sizeScale);
            balloonGroup.add(balloon);
            const minHeight = 50 + (sizeScale * 10);
            const maxHeight = Math.min(450, minHeight + 200);
            balloonGroup.position.set(
                Math.random() * 1600 - 800,
                minHeight + Math.random() * (maxHeight - minHeight),
                Math.random() * 1600 - 800
            );
            balloonGroup.boundingBox = new THREE.Box3();
            scene.add(balloonGroup);
            return balloonGroup;
        }
        for (let i = 0; i < 100; i++) targets.push(createBalloonTarget());

        // Player Movement
        let currentSpeed = 0;
        const minSpeed = 0;
        const maxSpeed = 2.0;
        const takeoffSpeed = 0.28;
        const speedIncrement = 0.02;
        const rollSpeed = 1.44;
        const maxRoll = Math.PI / 3;
        const yawRate = 1.44;
        const pitchSpeed = 0.9;
        const maxPitch = Math.PI / 2;
        let yawAngle = 0;
        let currentRoll = 0;
        let currentPitch = 0;
        const rollRecoverySpeed = 0.9;
        const liftFactor = 0.0015;
        const gravityFactor = 0.036;
        const minLiftSpeed = 0.2115;
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'KeyV') isThirdPerson = !isThirdPerson;
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        // Projectiles
        const projectiles = [];
        const PROJECTILE_SPEED = 2.0;
        const MAX_PROJECTILES = 1000;
        const FIRE_RATE = 50;
        const MAX_PROJECTILE_DISTANCE = 1000;
        let lastFireTime = 0;
        const dartGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2.0, 8);
        const dartTipGeometry = new THREE.ConeGeometry(0.2, 0.4, 8);
        const dartMaterial = new THREE.MeshPhongMaterial({ color: 0xff4444, roughness: 0.8, metalness: 0.1 });
        const dartTipMaterial = new THREE.MeshPhongMaterial({ color: 0xffaa44, roughness: 0.7, metalness: 0.2 });
        function shootFoamDart() {
            const dart = new THREE.Group();
            const body = new THREE.Mesh(dartGeometry, dartMaterial);
            body.rotation.x = Math.PI / 2;
            dart.add(body);
            const tip = new THREE.Mesh(dartTipGeometry, dartTipMaterial);
            tip.position.z = 1.2;
            tip.rotation.x = Math.PI / 2;
            dart.add(tip);
            const ringGeometry = new THREE.TorusGeometry(0.21, 0.05, 8, 16);
            for (let i = 0; i < 5; i++) {
                const ring = new THREE.Mesh(ringGeometry, dartMaterial);
                ring.position.z = (i * 0.4) - 0.8;
                dart.add(ring);
            }
            dart.position.copy(player.position);
            dart.rotation.copy(player.rotation);
            dart.translateZ(-2.5);
            const baseVelocity = new THREE.Vector3(0, 0, -PROJECTILE_SPEED).applyQuaternion(player.quaternion);
            const planeVelocity = new THREE.Vector3(0, 0, -currentSpeed).applyQuaternion(player.quaternion);
            dart.velocity = baseVelocity.add(planeVelocity);
            playShootSound();
            scene.add(dart);
            projectiles.push(dart);
            if (!isMobileDevice()) currentPitch -= 0.02;
        }
        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                for (let j = targets.length - 1; j >= 0; j--) {
                    const target = targets[j];
                    target.boundingBox.setFromObject(target);
                    if (target.boundingBox.containsPoint(projectile.position)) {
                        createHitEffect(projectile.position);
                        scene.remove(projectile);
                        scene.remove(target);
                        projectiles.splice(i, 1);
                        targets.splice(j, 1);
                        targetsHit++;
                        score += 100;
                        updateScoreDisplay();
                        break;
                    }
                }
                projectile.position.add(projectile.velocity.clone().multiplyScalar(deltaTime * 60));
                projectile.velocity.y -= 0.0005 * deltaTime * 60;
                if (projectile.position.distanceTo(player.position) > MAX_PROJECTILE_DISTANCE) {
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                    continue;
                }
                const direction = projectile.velocity.clone().normalize();
                projectile.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                const dartBox = new THREE.Box3().setFromObject(projectile);
                for (let j = ships.length - 1; j >= 0; j--) {
                    const ship = ships[j];
                    const shipBox = new THREE.Box3().setFromObject(ship);
                    if (dartBox.intersectsBox(shipBox)) {
                        createExplosionEffect(ship.position.clone());
                        scene.remove(ship);
                        scene.remove(projectile);
                        ships.splice(j, 1);
                        projectiles.splice(i, 1);
                        score += 1000;
                        break;
                    }
                }
                for (let j = buildings.length - 1; j >= 0; j--) {
                    const building = buildings[j];
                    const buildingBox = new THREE.Box3().setFromObject(building);
                    if (dartBox.intersectsBox(buildingBox)) {
                        createExplosionEffect(building.position.clone(), true);
                        scene.remove(building);
                        scene.remove(projectile);
                        buildings.splice(j, 1);
                        projectiles.splice(i, 1);
                        score += 250;
                        break;
                    }
                }
                for (let j = houses.length - 1; j >= 0; j--) {
                    const house = houses[j];
                    const houseBox = new THREE.Box3().setFromObject(house);
                    if (dartBox.intersectsBox(houseBox)) {
                        createExplosionEffect(house.position.clone(), true);
                        scene.remove(house);
                        scene.remove(projectile);
                        houses.splice(j, 1);
                        projectiles.splice(i, 1);
                        score += 250;
                        break;
                    }
                }
                for (let j = castle.parts.length - 1; j >= 0; j--) {
                    const part = castle.parts[j];
                    const partBox = new THREE.Box3().setFromObject(part);
                    if (dartBox.intersectsBox(partBox)) {
                        scene.remove(projectile);
                        projectiles.splice(i, 1);
                        part.health--;
                        if (part.health <= 0) {
                            createExplosionEffect(part.position.clone(), true);
                            scene.remove(part);
                            castle.parts.splice(j, 1);
                            switch (part.castlePartType) {
                                case 'keep': score += 5000; break;
                                case 'tower': score += 2000; break;
                                case 'roof': score += 1000; break;
                                case 'merlon': score += 500; break;
                            }
                        } else {
                            createHitEffect(projectile.position);
                        }
                        break;
                    }
                }
            }
        }

        // Audio
        let audioContext, engineOscillator, gainNode, shootSound, explosionSound, atcAudio;
        function setupEngineSound() {
            const audioCtx = window.audioContext;
            if (!audioCtx) return;
            engineOscillator = audioCtx.createOscillator();
            const engineOscillator2 = audioCtx.createOscillator();
            const engineOscillator3 = audioCtx.createOscillator();
            const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
            const noise = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseBuffer.length; i++) noise[i] = Math.random() * 2 - 1;
            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = noiseBuffer;
            noiseSource.loop = true;
            gainNode = audioCtx.createGain();
            const gainNode2 = audioCtx.createGain();
            const gainNode3 = audioCtx.createGain();
            const noiseGain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            engineOscillator.type = 'sawtooth';
            engineOscillator2.type = 'sine';
            engineOscillator3.type = 'square';
            engineOscillator.connect(gainNode);
            engineOscillator2.connect(gainNode2);
            engineOscillator3.connect(gainNode3);
            noiseSource.connect(noiseGain);
            gainNode.connect(filter);
            gainNode2.connect(filter);
            gainNode3.connect(filter);
            noiseGain.connect(filter);
            filter.connect(audioCtx.destination);
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            gainNode2.gain.setValueAtTime(0, audioCtx.currentTime);
            gainNode3.gain.setValueAtTime(0, audioCtx.currentTime);
            noiseGain.gain.setValueAtTime(0, audioCtx.currentTime);
            engineOscillator.start();
            engineOscillator2.start();
            engineOscillator3.start();
            noiseSource.start();
            window.engineSound = {
                osc1: engineOscillator,
                osc2: engineOscillator2,
                osc3: engineOscillator3,
                gain1: gainNode,
                gain2: gainNode2,
                gain3: gainNode3,
                noise: noiseGain,
                filter: filter
            };
        }
        function createShootSound() {
            const duration = 0.15;
            const audioCtx = window.audioContext;
            const shootBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
            const channelData = shootBuffer.getChannelData(0);
            for (let i = 0; i < shootBuffer.length; i++) {
                const t = i / audioCtx.sampleRate;
                const baseFreq = isMobileDevice() ? 30 : 50;
                const amplitude = Math.exp(isMobileDevice() ? -1 * t : -10 * t);
                const noise = isMobileDevice() ? (Math.random() * 2 - 1) * Math.exp(-5 * t) : 0;
                channelData[i] = amplitude * (
                    Math.sin(2 * Math.PI * baseFreq * t) +
                    (isMobileDevice() ? 1.5 : 0.7) * Math.sin(4 * Math.PI * baseFreq * t) +
                    (isMobileDevice() ? 1.25 : 0.5) * Math.sin(8 * Math.PI * baseFreq * t) +
                    (isMobileDevice() ? 1.5 * noise : 0.3 * Math.sin(8 * Math.PI * baseFreq * t))
                );
            }
            shootSound = shootBuffer;
        }
        function playShootSound() {
            if (!window.audioContext) return;
            const source = window.audioContext.createBufferSource();
            source.buffer = shootSound;
            const gainNode = window.audioContext.createGain();
            gainNode.gain.value = isMobileDevice() ? 0.4 : 2.0;
            const filter = window.audioContext.createBiquadFilter();
            filter.type = 'lowshelf';
            filter.frequency.value = 100;
            filter.gain.value = 20;
            const compressor = window.audioContext.createDynamicsCompressor();
            compressor.threshold.value = -24;
            compressor.knee.value = 30;
            compressor.ratio.value = 12;
            compressor.attack.value = 0.003;
            compressor.release.value = 0.25;
            source.connect(filter);
            filter.connect(compressor);
            compressor.connect(gainNode);
            gainNode.connect(window.audioContext.destination);
            source.start();
        }
        function createExplosionSound() {
            const duration = 0.5;
            const audioCtx = window.audioContext;
            const explosionBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
            const channelData = explosionBuffer.getChannelData(0);
            for (let i = 0; i < explosionBuffer.length; i++) {
                const t = i / audioCtx.sampleRate;
                const baseFreq = 30;
                const amplitude = Math.exp(-15 * t);
                const noise = (Math.random() * 2 - 1) * Math.exp(-5 * t);
                channelData[i] = amplitude * (
                    Math.sin(2 * Math.PI * baseFreq * t) +
                    0.5 * Math.sin(4 * Math.PI * baseFreq * t) +
                    0.25 * Math.sin(8 * Math.PI * baseFreq * t) +
                    0.5 * noise
                );
            }
            explosionSound = explosionBuffer;
        }
        function playExplosionSound() {
            if (!window.audioContext) return;
            const source = window.audioContext.createBufferSource();
            source.buffer = explosionSound;
            const gainNode = window.audioContext.createGain();
            gainNode.gain.value = 1.5;
            const filter = window.audioContext.createBiquadFilter();
            filter.type = 'lowshelf';
            filter.frequency.value = 150;
            filter.gain.value = 15;
            const compressor = window.audioContext.createDynamicsCompressor();
            compressor.threshold.value = -20;
            compressor.knee.value = 25;
            compressor.ratio.value = 12;
            compressor.attack.value = 0.005;
            compressor.release.value = 0.25;
            source.connect(filter);
            filter.connect(compressor);
            compressor.connect(gainNode);
            gainNode.connect(window.audioContext.destination);
            source.start();
        }
        function setupAtcAudio() {
            atcAudio = new Audio('https://pieter.com/lofiatcbrazil.stream');
            atcAudio.loop = true;
            atcAudio.volume = 0.3;
            const atcGainNode = window.audioContext.createGain();
            atcGainNode.gain.value = 0.3;
            const audioSource = window.audioContext.createMediaElementSource(atcAudio);
            audioSource.connect(atcGainNode);
            atcGainNode.connect(window.audioContext.destination);
        }
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // Camera
        camera.position.set(0, 38, 100);
        camera.lookAt(player.position);
        let mouseX = 0, mouseY = 0;
        let targetCameraOffset = new THREE.Vector3(0, 2, 10);
        const mouseSensitivity = 0.002;
        let isPointerLocked = false;
        let lastMouseMoveTime = Date.now();
        const MOUSE_TIMEOUT = 3000;
        let isThirdPerson = true;
        const COCKPIT_OFFSET = new THREE.Vector3(0, 1.0, -0.6);
        document.addEventListener('mousemove', event => {
            if (isPointerLocked) {
                mouseX -= event.movementX * mouseSensitivity;
                mouseY -= event.movementY * mouseSensitivity;
                mouseY = Math.max(-Math.PI / 3, Math.min(Math.PI / 4, mouseY));
                lastMouseMoveTime = Date.now();
            }
        });
        document.addEventListener('click', () => {
            if (hasStarted && !isPointerLocked) {
                document.body.requestPointerLock();
            }
        });
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === document.body;
        });
        document.addEventListener('keydown', e => {
            if (e.code === 'Escape') document.exitPointerLock();
        });

        // Joysticks
        let leftJoystick, rightJoystick;
        let leftJoystickData = { x: 0, y: 0 };
        let rightJoystickData = { x: 0, y: 0 };
        window.addEventListener('load', () => {
            leftJoystick = nipplejs.create({
                zone: document.getElementById('leftJoystick'),
                mode: 'static',
                position: { left: '50px', bottom: '50px' },
                color: 'white',
                size: 120
            });
            rightJoystick = nipplejs.create({
                zone: document.getElementById('rightJoystick'),
                mode: 'static',
                position: { right: '50px', bottom: '50px' },
                color: 'white',
                size: 120
            });
            leftJoystick.on('move', (evt, data) => {
                leftJoystickData.x = data.vector.x;
                leftJoystickData.y = data.vector.y;
            });
            leftJoystick.on('end', () => leftJoystickData = { x: 0, y: 0 });
            rightJoystick.on('move', (evt, data) => {
                rightJoystickData.y = data.vector.y;
                rightJoystickData.x = 0;
            });
            rightJoystick.on('end', () => rightJoystickData = { x: 0, y: 0 });
        });

        // Game State
        let hasStarted = false;
        let score = 0;
        let targetsHit = 0;
        let gameTime = 16000;
        const dayLength = 1200;
        let lastTime = performance.now();
        let frameCount = 0;
        let currentFps = 0;
        let deltaTime = 1 / 60;

        // Start Game
        function startGame() {
            if (hasStarted) return;
            hasStarted = true;
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            createShootSound();
            createExplosionSound();
            setupEngineSound();
            setupAtcAudio();
            atcAudio.play().catch(console.log);
            document.getElementById('startScreen').style.display = 'none';
            animate();
        }
        window.addEventListener('keydown', e => {
            if (document.getElementById('startScreen').style.display !== 'none') startGame();
        });
        document.getElementById('startButton').addEventListener('click', startGame);

        // Player Update
        const baseTurbulenceIntensity = 0.001;
        const baseTurbulenceFrequency = 0.02;
        function updatePlayer() {
            if (keys['KeyW'] || rightJoystickData.y > 0.3) {
                currentSpeed = Math.min(currentSpeed + speedIncrement * deltaTime, maxSpeed);
            } else if (keys['KeyS'] || rightJoystickData.y < -0.3) {
                currentSpeed = Math.max(currentSpeed - speedIncrement * 2 * deltaTime, minSpeed);
            }
            const isAirborne = player.position.y > 36.1;
            if (isAirborne) {
                if (keys['ArrowLeft'] || keys['KeyA'] || leftJoystickData.x < -0.3) {
                    currentRoll = Math.min(currentRoll + rollSpeed * deltaTime, maxRoll);
                    yawAngle += yawRate * deltaTime * (currentSpeed / maxSpeed);
                } else if (keys['ArrowRight'] || keys['KeyD'] || leftJoystickData.x > 0.3) {
                    currentRoll = Math.max(currentRoll - rollSpeed * deltaTime, -maxRoll);
                    yawAngle -= yawRate * deltaTime * (currentSpeed / maxSpeed);
                } else {
                    currentRoll = Math.abs(currentRoll) > 0.01 ? currentRoll - Math.sign(currentRoll) * rollRecoverySpeed * deltaTime : 0;
                }
            } else {
                currentRoll = 0;
                if (keys['ArrowLeft'] || keys['KeyA'] || leftJoystickData.x < -0.3) {
                    yawAngle += (yawRate * 2.0 + yawRate * 0.8 * (currentSpeed / maxSpeed)) * deltaTime;
                } else if (keys['ArrowRight'] || keys['KeyD'] || leftJoystickData.x > 0.3) {
                    yawAngle -= (yawRate * 2.0 + yawRate * 0.8 * (currentSpeed / maxSpeed)) * deltaTime;
                }
            }
            if (keys['ArrowUp'] || leftJoystickData.y > 0.3) {
                currentPitch = Math.max(currentPitch - pitchSpeed * deltaTime, -maxPitch);
            }
            if (keys['ArrowDown'] || leftJoystickData.y < -0.3) {
                currentPitch = Math.min(currentPitch + pitchSpeed * deltaTime, maxPitch);
            }
            player.translateZ(-currentSpeed);
            const speedKmh = currentSpeed * 525;
            if (speedKmh >= 74) player.position.y += (currentSpeed * liftFactor * deltaTime * 60) * Math.cos(currentRoll);
            if (player.position.y > 36) player.position.y -= gravityFactor * deltaTime * 60;
            else player.position.y = 36;
            if (isThirdPerson) {
                const currentTime = Date.now();
                if (currentTime - lastMouseMoveTime > MOUSE_TIMEOUT) {
                    const lerpFactor = 0.02 * deltaTime * 60;
                    mouseX *= (1 - lerpFactor);
                    mouseY *= (1 - lerpFactor);
                }
                const idealOffset = new THREE.Vector3(Math.sin(mouseX) * 10, Math.max(2 + Math.sin(mouseY) * 5, 1), Math.cos(mouseX) * 10);
                const offset = idealOffset.applyMatrix4(player.matrixWorld);
                camera.position.lerp(offset, 0.1);
                camera.position.y = Math.max(camera.position.y, 35.5);
                const lookAtPos = player.position.clone();
                lookAtPos.y += 1;
                camera.lookAt(lookAtPos);
            } else {
                const cockpitPos = player.localToWorld(COCKPIT_OFFSET.clone());
                camera.position.copy(cockpitPos);
                camera.quaternion.copy(player.quaternion);
                camera.rotateY(mouseX);
                camera.rotateX(mouseY);
            }
            if (window.engineSound) {
                const normalizedSpeed = Math.pow((currentSpeed - minSpeed) / (maxSpeed - minSpeed), 0.5);
                const baseFreq = 40 + normalizedSpeed * 100;
                window.engineSound.osc1.frequency.setValueAtTime(baseFreq, window.audioContext.currentTime);
                window.engineSound.osc2.frequency.setValueAtTime(baseFreq * 1.5, window.audioContext.currentTime);
                window.engineSound.osc3.frequency.setValueAtTime(baseFreq * 2, window.audioContext.currentTime);
                window.engineSound.gain1.gain.setValueAtTime(0.1 + normalizedSpeed * 0.3, window.audioContext.currentTime);
                window.engineSound.gain2.gain.setValueAtTime(0.05 + normalizedSpeed * 0.15, window.audioContext.currentTime);
                window.engineSound.gain3.gain.setValueAtTime(0.02 + normalizedSpeed * 0.06, window.audioContext.currentTime);
                window.engineSound.noise.gain.setValueAtTime(0.1 + normalizedSpeed * 0.3, window.audioContext.currentTime);
                window.engineSound.filter.frequency.setValueAtTime(800 + normalizedSpeed * 3000, window.audioContext.currentTime);
            }
            player.rotation.set(0, 0, 0);
            player.rotateY(yawAngle);
            player.rotateX(currentPitch);
            player.rotateZ(currentRoll);
            if (keys['Space']) {
                const currentTime = Date.now();
                if (currentTime - lastFireTime >= FIRE_RATE && projectiles.length < MAX_PROJECTILES) {
                    shootFoamDart();
                    lastFireTime = currentTime;
                }
            }
            let turbulenceIntensity = baseTurbulenceIntensity * (currentSpeed / maxSpeed) * deltaTime * 60;
            let turbulenceFrequency = baseTurbulenceFrequency * (currentSpeed / maxSpeed) * deltaTime * 60;
            if (keys['Space']) {
                turbulenceIntensity *= 3;
                turbulenceFrequency *= 2;
            }
            player.position.x += (Math.random() - 0.5) * turbulenceIntensity;
            player.position.y += (Math.random() - 0.5) * turbulenceIntensity;
            player.position.z += (Math.random() - 0.5) * turbulenceIntensity;
            player.rotation.x += (Math.random() - 0.5) * turbulenceFrequency;
            player.rotation.y += (Math.random() - 0.5) * turbulenceFrequency;
            player.rotation.z += (Math.random() - 0.5) * turbulenceFrequency;
            const currentTime = Date.now();
            if (currentTime - lastPositionUpdate > POSITION_UPDATE_INTERVAL) {
                broadcastPosition();
                lastPositionUpdate = currentTime;
            }
        }

        // Metrics and Score
        function updateMetrics() {
            const metricsDiv = document.getElementById('metrics');
            const currentTime = performance.now();
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                currentFps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
            const fpsColor = currentFps > 50 ? '#00ff00' : currentFps > 30 ? '#ffff00' : '#ff0000';
            const gameHours = Math.floor((gameTime / 24000) * 24);
            const gameMinutes = Math.floor(((gameTime / 24000) * 24 % 1) * 60);
            const timeString = `${gameHours.toString().padStart(2, '0')}:${gameMinutes.toString().padStart(2, '0')}`;
            const altitude = Math.round((player.position.y - 35.2) * 33.33);
            const speedKmh = Math.min(Math.round(currentSpeed * 525), 1235);
            const takeoffSpeedKmh = Math.round(takeoffSpeed * 525);
            const pitch = Math.round(currentPitch * (180 / Math.PI));
            const roll = Math.round(currentRoll * (180 / Math.PI));
            const heading = Math.round(((yawAngle * (180 / Math.PI)) + 180) % 360);
            const windSpeedKmh = Math.round(windSpeed * 100);
            const windDegrees = Math.round((windDirection * (180 / Math.PI) + 180) % 360);
            const throttlePercent = Math.round((currentSpeed / maxSpeed) * 100);
            metricsDiv.innerHTML = `
                <span style="color: ${fpsColor}">FPS: ${currentFps}</span><br>
                <span style="color: #00ff00">Balloons Hit: ${targetsHit}</span><br>
                <span style="color: #ff00ff">Balloons Left: ${targets.length}</span><br>
                Time: ${timeString}<br>
                <span style="color: #ffff00">Score: ${score}</span><br>
                <br>
                Altitude: ${altitude} ft<br>
                Speed: ${speedKmh} km/h ${speedKmh < takeoffSpeedKmh ? '(Need ' + takeoffSpeedKmh + ' km/h for takeoff)' : ''}<br>
                Throttle: ${throttlePercent}%<br>
                Pitch: ${pitch}Â°<br>
                Roll: ${roll}Â°<br>
                Heading: ${heading}Â°<br>
                Wind: ${windSpeedKmh} km/h at ${windDegrees}Â°<br>
                <br>
                Controls:<br>
                W/S - Throttle Up/Down<br>
                â†/â†’ or A/D - Turn Left/Right<br>
                â†‘/â†“ - Pitch Up/Down<br>
                SPACE - Shoot Missiles<br>
                V - Toggle Camera View<br>
                <br>
                Tap to hide
            `;
        }
        let metricsVisible = true;
        document.getElementById('metrics').addEventListener('click', function() {
            metricsVisible = !metricsVisible;
            this.style.opacity = metricsVisible ? '1' : '0';
            this.style.pointerEvents = metricsVisible ? 'auto' : 'none';
        });
        function updateScoreDisplay() {
            const scoreDiv = document.getElementById('scoreOverlay');
            scoreDiv.textContent = `ðŸŽˆ${targetsHit}/100`;
            scoreDiv.style.transform = 'scale(1.2)';
            setTimeout(() => scoreDiv.style.transform = 'scale(1)', 200);
        }

        // Day-Night Cycle
        function updateDayNightCycle() {
            gameTime += deltaTime * 240;
            if (gameTime >= 24000) gameTime -= 24000;
            const dawnStart = 5000, dawnEnd = 7000, duskStart = 17000, duskEnd = 19000;
            let transitionFactor = 0, moonVisibility = 0;
            if (gameTime >= dawnStart && gameTime <= dawnEnd) {
                transitionFactor = (gameTime - dawnStart) / (dawnEnd - dawnStart);
                moonVisibility = Math.max(0.1, 1 - transitionFactor);
            } else if (gameTime >= duskStart && gameTime <= duskEnd) {
                transitionFactor = 1 - ((gameTime - duskStart) / (duskEnd - duskStart));
                moonVisibility = Math.max(0.1, 1 - transitionFactor);
            } else if (gameTime > dawnEnd && gameTime < duskStart) {
                transitionFactor = 1;
                moonVisibility = 0.1;
            } else {
                moonVisibility = 1;
            }
            moonMaterial.opacity = moonVisibility;
            const dayColor = 0x00ffff, nightColor = 0x1a1a3a;
            const sunColor = new THREE.Color(nightColor).lerp(new THREE.Color(dayColor), transitionFactor);
            const skyColor = new THREE.Color(nightColor).lerp(new THREE.Color(dayColor), transitionFactor);
            const sunIntensity = 0.2 + (transitionFactor * 0.8);
            const ambientIntensity = 0.7 + (transitionFactor * 0.1);
            sunLight.color.copy(sunColor);
            sunLight.intensity = sunIntensity;
            ambientLight.intensity = ambientIntensity;
            scene.background.copy(skyColor);
            scene.fog.color.copy(skyColor);
            const runwayLightIntensity = Math.max(0, 1.5 - (transitionFactor * 1.5));
            runwayLights.forEach(light => {
                light.mesh.material.emissiveIntensity = runwayLightIntensity;
                light.light.intensity = runwayLightIntensity * 2;
            });
        }

        // Effects
        function createHitEffect(position) {
            const particles = new THREE.Group();
            for (let i = 0; i < 20; i++) {
                const geometry = new THREE.SphereGeometry(0.2, 8, 8);
                const material = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0xffaa00 });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3((Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3);
                particles.add(particle);
            }
            scene.add(particles);
            let elapsedTime = 0;
            function animateHit() {
                elapsedTime += deltaTime;
                particles.children.forEach(particle => {
                    particle.position.add(particle.velocity.clone().multiplyScalar(deltaTime * 60));
                    particle.material.opacity = 1 - elapsedTime;
                    particle.material.transparent = true;
                });
                if (elapsedTime < 1) requestAnimationFrame(animateHit);
                else scene.remove(particles);
            }
            animateHit();
        }
        function createExplosionEffect(position, isLarge = false) {
            playExplosionSound();
            const particleCount = isLarge ? 50 : 20;
            const particleSize = isLarge ? 2 : 0.5;
            const explosionSpeed = isLarge ? 30 : 10;
            const particles = new THREE.Group();
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.BoxGeometry(particleSize, particleSize, particleSize);
                const material = new THREE.MeshPhongMaterial({
                    color: isLarge ? 0xff4400 : 0xff0000,
                    emissive: isLarge ? 0xff4400 : 0xff0000,
                    emissiveIntensity: 0.5
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = Math.random() * explosionSpeed;
                particle.velocity = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.cos(phi),
                    Math.sin(phi) * Math.sin(theta)
                ).multiplyScalar(speed);
                particles.add(particle);
            }
            scene.add(particles);
            let elapsedTime = 0;
            function animateExplosion() {
                elapsedTime += deltaTime;
                particles.children.forEach(particle => {
                    particle.position.add(particle.velocity.clone().multiplyScalar(deltaTime * 60));
                    particle.velocity.y -= (isLarge ? 0.1 : 0.01) * deltaTime * 60;
                    particle.material.opacity = 1 - elapsedTime;
                    particle.material.transparent = true;
                    particle.rotation.x += 0.1 * deltaTime * 60;
                    particle.rotation.y += 0.1 * deltaTime * 60;
                });
                if (elapsedTime < 1) requestAnimationFrame(animateExplosion);
                else scene.remove(particles);
            }
            animateExplosion();
        }

        // Collisions
        function checkCollisions() {
            const playerBox = new THREE.Box3().setFromObject(player);
            const castleBox = new THREE.Box3().setFromObject(castle);
            if (playerBox.intersectsBox(castleBox)) return gameOver("CRASHED INTO CASTLE!");
            targets.forEach(target => {
                target.boundingBox.setFromObject(target);
                if (playerBox.intersectsBox(target.boundingBox)) return gameOver("CRASHED INTO BALLOON!");
            });
            const towerBox = new THREE.Box3().setFromObject(towerGroup);
            if (playerBox.intersectsBox(towerBox)) return gameOver("CRASHED INTO CONTROL TOWER!");
            for (let house of houses) {
                const houseBox = new THREE.Box3().setFromObject(house);
                if (playerBox.intersectsBox(houseBox)) return gameOver("CRASHED INTO HOUSE!");
            }
        }
        function gameOver(message) {
            if (window.gameEnded) return;
            window.gameEnded = true;
            cancelAnimationFrame(animationFrameId);
            if (window.engineSound) {
                window.engineSound.osc1.stop();
                window.engineSound.osc2.stop();
                window.engineSound.osc3.stop();
            }
            if (atcAudio) atcAudio.pause();
            if (window.audioContext && window.audioContext.state !== 'closed') window.audioContext.close();
            const canvas = renderer.domElement;
            canvas.style.filter = 'grayscale(100%) brightness(70%)';
            canvas.style.transition = 'filter 1s';
            const gameOverScreen = document.createElement('div');
            gameOverScreen.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0, 0, 0, 0.5); display: flex; flex-direction: column;
                justify-content: center; align-items: center; z-index: 1000;
                font-family: 'Courier New', monospace; color: #ff0000; text-shadow: 0 0 5px #ff0000;
            `;
            const wastedText = document.createElement('h1');
            wastedText.textContent = 'WASTED';
            wastedText.style.cssText = 'font-size: 96px; font-weight: bold; opacity: 0; transition: opacity 1s;';
            gameOverScreen.appendChild(wastedText);
            setTimeout(() => wastedText.style.opacity = '1', 0);
            const restartButton = document.createElement('button');
            restartButton.textContent = 'Restart Game';
            restartButton.style.cssText = `
                padding: 20px 40px; font-size: 24px; cursor: pointer; background: #00ff00;
                color: #000000; border: 2px solid #00ff00; box-shadow: 0 0 10px #00ff00;
                border-radius: 5px; margin-top: 20px; opacity: 0; transition: opacity 1s;
            `;
            restartButton.onclick = () => location.reload();
            gameOverScreen.appendChild(restartButton);
            setTimeout(() => restartButton.style.opacity = '1', 0);
            document.body.appendChild(gameOverScreen);
        }

        // WebRTC
        let peer, localPeerId, connections = {};
        const otherPlayers = new Map();
        let lastPositionUpdate = 0;
        const POSITION_UPDATE_INTERVAL = 50;
        function getPeerId() {
            return new URLSearchParams(window.location.search).get('id');
        }
        function setPeerId(id) {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('id', id);
            window.history.replaceState({}, '', newUrl);
        }
        async function setupWebRTC() {
            peer = new Peer(undefined, {
                host: '0.peerjs.com',
                secure: true,
                port: 443,
                path: '/',
                config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }] }
            });
            peer.on('open', id => {
                localPeerId = id;
                const targetPeerId = getPeerId();
                if (!targetPeerId) setPeerId(id);
                showConnectionUI();
                if (targetPeerId && targetPeerId !== id) connectToPeer(targetPeerId);
            });
            peer.on('connection', conn => handleNewConnection(conn));
            peer.on('error', err => updateConnectionUI('Connection error: ' + err.message));
        }
        function showConnectionUI() {
            const connectionUI = document.getElementById('connectionUI');
            const joiningId = getPeerId();
            if (!joiningId) {
                const shareSection = document.createElement('div');
                shareSection.style.cssText = 'padding: 8px; background: rgba(255,255,255,0.1); border-radius: 5px;';
                const shareLink = `${window.location.origin}${window.location.pathname}?id=${localPeerId}`;
                const linkDisplay = document.createElement('div');
                linkDisplay.textContent = 'Share this link to play with a friend:';
                linkDisplay.style.cssText = 'margin-bottom: 5px; font-size: 12px;';
                shareSection.appendChild(linkDisplay);
                const linkInput = document.createElement('input');
                linkInput.value = shareLink;
                linkInput.readOnly = true;
                linkInput.style.cssText = 'width: 100%; padding: 4px; border-radius: 3px; border: 1px solid #00ffff; font-size: 12px;';
                shareSection.appendChild(linkInput);
                const copyLinkButton = document.createElement('button');
                copyLinkButton.textContent = 'Copy Link';
                copyLinkButton.style.cssText = 'margin-top: 5px; padding: 4px 8px; cursor: pointer; border: none; border-radius: 3px; background: #00ff00; color: #000000; font-size: 12px;';
                copyLinkButton.onclick = () => {
                    navigator.clipboard.writeText(shareLink);
                    copyLinkButton.textContent = 'Copied!';
                    setTimeout(() => copyLinkButton.textContent = 'Copy Link', 2000);
                };
                shareSection.appendChild(copyLinkButton);
                connectionUI.appendChild(shareSection);
            }
        }
        function connectToPeer(peerId) {
            if (!peer || peerId === localPeerId) return;
            const conn = peer.connect(peerId);
            handleNewConnection(conn);
        }
        function handleNewConnection(conn) {
            if (!conn) return;
            conn.on('open', () => {
                connections[conn.peer] = conn;
                updateConnectionUI('Connected to: ' + conn.peer);
                conn.on('data', data => handlePeerData(data, conn.peer));
            });
            conn.on('close', () => {
                delete connections[conn.peer];
                updateConnectionUI('Connection closed');
            });
        }
        function updateConnectionUI(message) {
            const status = document.getElementById('connectionUI');
            if (status) status.textContent = message;
        }
        function handlePeerData(data, peerId) {
            if (data.type === 'position') {
                let otherPlane = otherPlayers.get(peerId);
                if (!otherPlane) {
                    otherPlane = createOtherPlayerPlane();
                    scene.add(otherPlane);
                    otherPlayers.set(peerId, otherPlane);
                }
                otherPlane.position.set(data.data.x, data.data.y, data.data.z);
                otherPlane.rotation.set(data.data.rotationX, data.data.rotationY, data.data.rotationZ);
            }
        }
        function createOtherPlayerPlane() {
            const otherPlane = new THREE.Group();
            const fuselage = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 4), new THREE.MeshPhongMaterial({ color: 0xff0000 }));
            const wings = new THREE.Mesh(new THREE.BoxGeometry(7, 0.2, 2), new THREE.MeshPhongMaterial({ color: 0xff0000 }));
            wings.position.y = 0.1;
            const tail = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 0.5), new THREE.MeshPhongMaterial({ color: 0xff0000 }));
            tail.position.set(0, 0.4, -1.8);
            otherPlane.add(fuselage);
            otherPlane.add(wings);
            otherPlane.add(tail);
            return otherPlane;
        }
        function broadcastPosition() {
            if (!peer || !localPeerId) return;
            const positionData = {
                type: 'position',
                data: {
                    x: player.position.x,
                    y: player.position.y,
                    z: player.position.z,
                    rotationX: player.rotation.x,
                    rotationY: player.rotation.y,
                    rotationZ: player.rotation.z,
                    speed: currentSpeed,
                    timestamp: Date.now()
                }
            };
            Object.values(connections).forEach(conn => {
                try {
                    conn.send(positionData);
                } catch (err) {}
            });
        }
        window.addEventListener('load', () => setupWebRTC());

        // Animation Loop
        let lastFrameTime = performance.now();
        let animationFrameId;
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const currentTime = performance.now();
            deltaTime = Math.min((currentTime - lastFrameTime) / 1000, 1 / 30);
            lastFrameTime = currentTime;
            updatePlayer();
            updateProjectiles();
            checkCollisions();
            updateClouds();
            updateDayNightCycle();
            animateWindsock();
            updateMetrics();
            updateApproachLights();
            updateShips();
            renderer.render(scene, camera);
        }

        // Window Resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', onWindowResize);
        renderer.render(scene, camera);
    </script>
</body>
</html>